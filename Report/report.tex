% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\makeatletter
\usepackage[algoruled,boxed,lined]{algorithm2e}
\makeatletter
\g@addto@macro{\@algocf@init}{\SetKwInOut{Parameter}{Parameters}}
\makeatother
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{syntaktische Mehrdeutigkeiten beim Parsen}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Lennart Protte\inst{1}}
%
\authorrunning{Author}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{RWTH Aachen University \email{lennart.protte@rwth-aachen.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
    Syntaktische Mehrdeutigkeiten stellen eine zentrale Herausforderung beim Parsen von Programmiersprachen dar.

    Diese Arbeit untersucht die theoretischen Grundlagen und praktischen Auswirkungen solcher Mehrdeutigkeiten
    und bietet Einblicke in moderne Ansätze zu ihrer Vermeidung und Auflösung.
    Wir analysieren die Ursachen von Mehrdeutigkeiten und deren Einfluss auf die Effizienz und Zuverlässigkeit von Parsern.
    Dabei beleuchten wir verschiedene Strategien, von der sprachlichen Gestaltung über Assoziativitäts- und Vorrangregeln
    bis hin zu fortschrittlichen Algorithmen wie dem Dynamic1-Algorithmus und den Techniken von Vasudevan und Tratt.
    Die Arbeit zeigt auf, wie eindeutige Sprachdesigns die Komplexität des Parsens reduzieren können und welche Kompromisse dabei eingegangen werden müssen.
    Durch Fallstudien und praktische Beispiele verdeutlichen wir die Anwendung dieser Konzepte in realen Projekten
    und bieten einen Ausblick auf zukünftige Entwicklungen im Sprachdesign und Parserbau.
    \keywords{Compilerbau, Syntaktische Mehrdeutigkeiten, Sprachdesign}
\end{abstract}
%
%
%

%Sample citation: \cite{gelman2013bayesian}.
%See Springer website\footnote{\url{https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines}.} for further inforamtion on the \LaTeX style.
\section{Einführung}
Bei der Handhabung von Mehrdeutigkeiten, bietet es sich an, die Grammatiken der Sprachen zu betrachten.
Dabei stellt sich die Frage nach der Definition von Mehrdeutigkeit
und nach der Bedeutung für die syntaktische Analyse im Parserbau.
Es gilt: ``Eine Grammatik ist genau dann mehrdeutig, wenn es mindestens eine Eingabe gibt, die mehrere Parse-Bäume besitzt.''

Bei Mehrdeutigkeiten lässt sich zwischen lexikalischer und syntaktischer Mehrdeutigkeit unterscheiden.
Lexikalische Mehrdeutigkeiten treten auf, wenn ein Token mehrere Bedeutungen haben kann.
Ein Beispiel hierfür ist die lexikalische Mehrdeutigkeit des Tokens ``+'' in der Programmiersprache Java.
Syntaktische Mehrdeutigkeiten hingegen entstehen durch die Struktur der Grammatik selbst.
Das bekannteste Beispiel hierfür ist das ``Dangling else''-Problem, das in vielen Programmiersprachen auftritt.
HIER BEISPIEL DANGLING-ELSE
Wie dieses Beispiel erkennen lässt,
können syntaktische Mehrdeutigkeiten zu unterschiedlichen Interpretationen desselben Quellcodes führen.
Die Problematik dessen wird im Folgenden behandelt.


\section{Problemstellung}


- Relevanz des Problems
- Problematik von Mehrdeutigkeiten beim Parsen
- Performance-Einbußen durch Mehrdeutigkeiten
- Schwierigkeiten in der Optimierung von Compiler-Implementierungen
- Beispielhafte Fehlerfälle und ihre Folgen
- Schwierigkeit des Problems
- Theoretische Grenzen der Mehrdeutigkeitsauflösung
- Beispiel: "P versus NP"-Problematik im Kontext von Parsing
- Komplexität der Implementierung und Wartung von Parsern

\section{Vermeidung von Mehrdeutigkeiten}
- Design von Sprachen die eindeutig sind
- Methoden zur Vermeidung von Mehrdeutigkeit beim Sprachdesign
- Assoziativität, Vorrangregeln
- Vorteile und Nachteile von eindeutigen Sprachen
- Vorteile einfacherer Parser
- Kosteneinsparungen bei der Entwicklung und Wartung
- Bessere Performance durch einfachere Algorithmen
- LL Parser
- Nachteile: Einschränkung der Sprache
- Beispiele für Sprachen, die durch Eindeutigkeitsanforderungen eingeschränkt sind

\section{Erkennung von Mehrdeutigkeiten}
- Suchbasierte Erkennung
- bekannte Algorithmen
- Tiefen/Breiten-Suche
- Beispielhafte Implementierungen
-Laufzeit vergleich
- dynamic1 Algorithmus

\section{Auflösung von Mehrdeutigkeiten}
-algorithmus von Vasudevan und Tratt
- beispiel
-chomsky normalform zur auflösung
- LL(k)- und LR(k)-Parser im Detail
- Unterschiede und Gemeinsamkeiten
- Beispielhafte Implementierungen

\section{Parsen von Mehrdeutigkeiten}
- Erweiterte Heuristiken zur Mehrdeutigkeitsauflösung
- Nutzung von Backtracking und Lookahead-Techniken
- Parser-Generatoren
- Spezifische Parser-Techniken (z.B. Early-Parser, Chart-Parser)
- Abschließend: Vergleich LL, LR, LALR, SLR, Earley-Parser

\section{Praktische Beispiele}
- wo findet das anwendung?
- Anwendungen in Compilerbau, Sprachverarbeitung und maschinellem Lernen
-parser generatoren
- early-parser/chart parser

\section{Zusammenfassung und Ausblick}
- eindeutige sprachen erleichtern das Schreiben von code
- Vorteile für die Entwickler: Effizienz und Fehlervermeidung

- erleichtern das parsen
- trend geht aber in andere richtung (zukünftige Entwicklungen im Sprachdesign)
- neue programmiersprachen sind oft mehrdeutig
- beispiel: python

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{refs}
\end{document}
