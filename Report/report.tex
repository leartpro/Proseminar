% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\makeatletter
\usepackage[algoruled,boxed,lined]{algorithm2e}
\makeatletter
\g@addto@macro{\@algocf@init}{\SetKwInOut{Parameter}{Parameters}}
\makeatother
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
	\title{syntaktische Mehrdeutigkeiten beim Parsen}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
	\author{Lennart Protte\inst{1}}
%
	\authorrunning{Author}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
	\institute{RWTH Aachen University \email{lennart.protte@rwth-aachen.de}}
%
	\maketitle              % typeset the header of the contribution
%
	\begin{abstract}
		Syntaktische Mehrdeutigkeiten stellen eine zentrale Herausforderung beim Parsen von Programmiersprachen dar.
		Diese vorliegende Arbeit untersucht die Auswirkungen solcher Mehrdeutigkeiten
		und betrachtet dabei moderne Ansätze zu ihrer Erkennung, Vermeidung und Auflösung.
		Dabei werden die Vor- und Nachteile von mehrdeutigen Sprachen und Grammatiken diskutiert
		und die Auswirkungen auf die Effizienz und Komplexität von Parsern beleuchtet.

		Um diese Problematik zu lösen,
		wurden Strategien und Algorithmen zur Erkennung und behebung syntaktischer Mehrdeutigkeiten diskutiert.
		Es zeigt sich, dass die Vermeidung von Mehrdeutigkeiten in Grammatiken eine effiziente und zuverlässige Analyse ermöglicht,
		allerdings nicht immer sinvoll ist.

		Die Arbeit stellt effektive Methoden zur Erkennung und Auflösung von Mehrdeutigkeiten vor
		und zeigt wie moderne Parser-Techniken dieser Problematik begegnen.

		Die Abwägung zwischen der Einfachheit der Grammatik und der Lesbarkeit der Sprache zeigt,
		dass eindeutige Sprachdesigns die Komplexität des Parsens reduzieren können,
		aber Mehrdeutigkeiten nicht immer ein Hindernis darstellen müssen.

		\keywords{Compilerbau, Syntaktische Mehrdeutigkeiten, Sprachdesign}
	\end{abstract}
	%
	%Sample citation: \cite{gelman2013bayesian}.
	%See Springer website\footnote{\url{https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines}.}
	%for further inforamtion on the \LaTeX style.
	%


	\section{Einführung}
	Bei der Handhabung von Mehrdeutigkeiten, bietet es sich an, die Grammatiken der Sprachen zu betrachten.
	Dabei stellt sich die Frage nach der Definition von Mehrdeutigkeit
	und nach der Bedeutung für die syntaktische Analyse im Parserbau.
	Es gilt: ``Eine Grammatik ist genau dann mehrdeutig, wenn es mindestens eine Eingabe gibt, die mehrere Parse-Bäume besitzt.''

	Bei Mehrdeutigkeiten lässt sich zwischen lexikalischer und syntaktischer Mehrdeutigkeit unterscheiden.
	Lexikalische Mehrdeutigkeiten treten auf, wenn ein Token mehrere Bedeutungen haben kann.
	Ein Beispiel hierfür ist die lexikalische Mehrdeutigkeit des Tokens ``+'' in der Programmiersprache Java.

	\begin{verbatim}
		int a = 1 + 2;
		a++;
		String b = "Hello" + "World";
	\end{verbatim}

	Syntaktische Mehrdeutigkeiten hingegen entstehen durch die Struktur der Grammatik selbst.
	Das bekannteste Beispiel hierfür ist das ``Dangling else''-Problem, das in vielen Programmiersprachen auftritt.

	HIER BEISPIEL DANGLING-ELSE


	Wie dieses Beispiel erkennen lässt,
	können syntaktische Mehrdeutigkeiten zu unterschiedlichen Interpretationen desselben Quellcodes führen.
	Die Problematik dessen wird im Folgenden behandelt.


	\section{Problemstellung}

	Mehrdeutigkeiten in Grammatiken von Programmiersprachen
	spielen eine entscheidene Rolle bei der Konzeption der Sprache,
	so wie bei der Implementierung des zugehörigen Parsers.
	Wenn Mehrdeutigkeiten inhärent in der Grammatik vorhanden sind,
	muss sich der Parser mit der Auflösung dieser Mehrdeutigkeiten auseinandersetzen.
	Dies kann zu einer erhöhten Komplexität des Parsers führen
	und je nach Parser zu einer nicht-deterministischen Laufzeit oder sogar einem nicht terminierendem Lauf.
	Das liegt daran, dass ein Parser alle möglichen Interpretationen eines Satzes finden muss, um die richtige zu identifizieren.
	So muss der Parser potenziell exponentiell viele Möglichkeiten in Betracht ziehen.
	Auch das Programmieren in eine Sprache mit Mehrdeutigkeiten kann zu unerwartetem Verhalten führen
	und damit die Effizienz in der in dieser Sprache entwickelt wird, beeinträchtigen.

	Die vollständige Beseitigung von Mehrdeutigkeiten in einer kontextfreien Grammatik ist nicht immer möglich.
	So sind einige Probleme, wie das oben erwähnte ``Dangling Else''-Problem,
	inhärent mehrdeutig und benötigen zusätzliche Kontexte oder heuristische Ansätze, um aufgelöst zu werden.
	Auf der anderen Seite ist eine eindeutige Grammatik einfacher zu parsen und zu verstehen,
	aber sie kann auch eine Einschränkung der Sprache bedeuten.


	\section{Vermeidung von Mehrdeutigkeiten}

	Da Mehrdeutigkeiten in Grammatiken sowohl in der Entwicklung des Parsers,
	als auch in der Anwendung der Sprache hinderlich sein können,
	ist es sinnvoll Mehrdeutigkeiten von vornherein zu vermeiden.
	Um eine Sprache eindeutig zu gestalten,
	können beispielsweise Assoziativitäts- und Vorrangregeln festgelegt werden,
	die eine eindeutige Struktur der Grammatik garantieren. \cite{wharton1976}
	Eine solche Sprache kann effizient und in linearer Zeit von einem LL-Parser verarbeitet werden.

	Allerdings kann es auch Nachteile haben, eine Sprache eindeutig zu gestalten.
	So ist die Grammatik einer mehrdeutigen Sprache oft einfacher, kürzer und intuitiver als die einer eindeutigen Sprache.
	So können die Eindeutigkeitsanforderungen and eine Sprache schnell Boilplate-Code verursachen.
	Es ist also eine Abwägung zwischen der Einfachheit des Parsers und der Komplexität und Lesbarkeit der Sprache zu treffen.


	\section{Erkennung von Mehrdeutigkeiten}

	Wenn die Vermeidung von Mehrdeutigkeiten nicht möglich ist,
	muss der Parser in der Lage sein, Mehrdeutigkeiten zu erkennen und aufzulösen.
	Wie Mehrdeutigkeiten algorithmisch erkannt werden können wird im Folgenden erläutert.
	Zum einen besteht die Möglichkeit alle möglichen Ableitungen eines gegebenen Wortes zu ermitteln.
	Um mit dieser Methode zu prüfen, ob eine Grammatik mehrdeutig ist,
	können Wörter nach Heuristiken generiert und anschließend analysiert werden.
	Die Analyse kann entweder durch eine Tiefen- oder Breitensuche erfolgen.
	Bei der Tiefensuche wird die Grammatik rekursiv abgeleitet,
	während bei der Breitensuche alle möglichen Ableitungen auf einer Ebene betrachtet werden.
	HIER GRAFIK
	Dieser Ansatz basiert allerdings auf dem Brute-Force-Prinzip und ist daher nicht effizient.
	Effizientere Methoden sind bekannter Algorithmen wie derCYK-Algorithmus oder der Earley-Parser.
	Diese werden im Weiteren genauer erläutert und verglichen.

	- Suchbasierte Erkennung
	- bekannte Algorithmen
	- Tiefen/Breiten-Suche
	- Beispielhafte Implementierungen
	-Laufzeit vergleich
	- dynamic1 Algorithmus


	\section{Auflösung von Mehrdeutigkeiten}

	Sollte eine Grammatik mehrdeutig sein, so muss ein Parser in der Lage sein, diese Mehrdeutigkeiten aufzulösen.
	Eine Möglichkeit dies zu tun ist die Umformung der Grammatik in die Chomsky-Normalform.
	Bei der Umformung in die CNF können Mehrdeutigkeiten aufgelöst werden, müssen aber nicht.
	Ein weiterer Ansatz besteht darin, immer den ersten Ableitungsschritt zu wählen, wenn mehrere Ableitungen möglich sind.
	Dieser Ansatz ist jedoch nicht immer korrekt und kann zu falschen Interpretationen führen.
	Eine weitere Möglichkeit besteht darin, den Parser so zu erweitern,
	dass er in der Lage ist, mehrere Interpretationen zu verfolgen und zu vergleichen.
	Parser mit dieser Fähigkeit werden als Chart-Parser bezeichnet und im Folgenden genauer erläutert.
	Wenn zu einer Grammatik zusätzliche Regel wie Assoziativitäts- und Vorrangregeln existieren,
	können diese genutzt werden, um Mehrdeutigkeiten aufzulösen. \cite{springer2013}
	- LL(k)- und LR(k)-Parser im Detail
	- Unterschiede und Gemeinsamkeiten


	\section{Parsen von Mehrdeutigkeiten}

	- Erweiterte Heuristiken zur Mehrdeutigkeitsauflösung
	- Nutzung von Backtracking und Lookahead-Techniken
	- Parser-Generatoren
	- Spezifische Parser-Techniken (z.B. Early-Parser, Chart-Parser)
	- Abschließend: Vergleich LL, LR, LALR, SLR, Earley-Parser


	\section{Praktische Beispiele}

	Die Handhabung von Mehrdeutigkeiten ist neben dem Compilerbau
	auch in Bereichen wie der Sprachverarbeitung und dem maschinellen Lernen von Bedeutung.
	So behandeln Parser-Generatoren wie ANTLR oder Bison die Problematik der Mehrdeutigkeiten
	und bieten dem Nutzer Möglichkeiten zur Auflösung.
	Auch in der Sprachverarbeitung und dem maschinellen Lernen sind Mehrdeutigkeiten ein zentrales Thema.
	So können Sprachmodelle wie BERT oder GPT-3 durch die Handhabung von Mehrdeutigkeiten
	bessere Ergebnisse erzielen und die Effizienz der Verarbeitung steigern.
	STIMMT DAS SO?


	\section{Zusammenfassung und Ausblick}

	Abschließend lässt sich festhalten, dass Mehrdeutigkeiten in Grammatiken von Programmiersprachen
	eine zentrale Herausforderung beim Parsen darstellen.
	Die Vermeidung und Auflösung von Mehrdeutigkeiten kann die Effizienz und Zuverlässigkeit von Parsern erhöhen
	und die Entwicklung in der Sprache erleichtern.
	Sie kann aber auch zu Einschränkungen in der Sprache führen und die Lesbarkeit des Codes beeinträchtigen.
	Mehrdeutige Sprachen sind oft einfacher und intuitiver zu verstehen
	und die Tatsache, dass viele gängige Programmiersprachen wie C, Java oder Python mehrdeutig sind,
	zeigt, dass Mehrdeutigkeiten nicht immer ein Hindernis darstellen müssen.

	Neuere Programmiersprachen sind oft mehrdeutig und setzen auf fortschrittliche Parser-Techniken,
	um Mehrdeutigkeiten effizient aufzulösen.
	Auch existieren immer mehr Ansätze, die auf natürliche Sprache setzten
	und somit hin zu mehrdeutigen Sprachen tendieren.
	\cite{watrous2020,springer2013,wharton1976,watrous,parr,kemp1974,qi2018generalized,softwarelanguage,thorup1994}


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
	\bibliographystyle{splncs04}
	\bibliography{refs}
\end{document}
