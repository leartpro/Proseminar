% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\makeatletter
\usepackage[algoruled,boxed,lined]{algorithm2e}
\makeatletter
\g@addto@macro{\@algocf@init}{\SetKwInOut{Parameter}{Parameters}}
\makeatother
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{automata, positioning}
\usepackage{listings}
\lstset{basicstyle=\ttfamily}
\usepackage{tcolorbox}
\usepackage{framed}
\usepackage{forest}
\usepackage{xcolor}
\usepackage{blkarray}
\usepackage{comment}

\lstdefinestyle{cppStyle}{
	language=C++,
	basicstyle=\small\ttfamily,
	tabsize=4,
	breaklines=true,
	showtabs=false,
	showspaces=false,
	showstringspaces=false,
	columns=flexible
}

\begin{document}
%
	\title{syntaktische Mehrdeutigkeiten beim Parsen}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
	\author{Lennart Protte\inst{1}}
%
	\authorrunning{Author}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
	\institute{RWTH Aachen University \email{lennart.protte@rwth-aachen.de}}
%
	\maketitle              % typeset the header of the contribution
%
	\begin{abstract}
		Syntaktische Mehrdeutigkeiten stellen eine zentrale Herausforderung beim Parsen von Programmiersprachen dar.
		Diese vorliegende Arbeit untersucht die Auswirkungen solcher Mehrdeutigkeiten
		und betrachtet dabei moderne Ansätze zu ihrer Erkennung, Vermeidung und Auflösung.
		Dabei werden die Vor- und Nachteile von mehrdeutigen Sprachen und Grammatiken diskutiert
		und die Auswirkungen auf die Effizienz und Komplexität von Parsern beleuchtet.

		Um diese Problematik zu lösen,
		wurden Strategien und Algorithmen zur Erkennung und behebung syntaktischer Mehrdeutigkeiten diskutiert.
		Es zeigt sich, dass die Vermeidung von Mehrdeutigkeiten in Grammatiken eine effiziente und zuverlässige Analyse ermöglicht,
		allerdings nicht immer sinvoll ist.

		Die Arbeit stellt effektive Methoden zur Erkennung und Auflösung von Mehrdeutigkeiten vor
		und zeigt wie moderne Parser-Techniken dieser Problematik begegnen.

		Die Abwägung zwischen der Einfachheit der Grammatik und der Lesbarkeit der Sprache zeigt,
		dass eindeutige Sprachdesigns die Komplexität des Parsens reduzieren können,
		aber Mehrdeutigkeiten nicht immer ein Hindernis darstellen müssen.

		\keywords{Compilerbau, Syntaktische Mehrdeutigkeiten, Sprachdesign}
	\end{abstract}
	%
	%Sample citation: \cite{gelman2013bayesian}.
	%See Springer website\footnote{\url{https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines}.}
	%for further inforamtion on the \LaTeX style.
	%


	\section{Einführung}
	Bei der Handhabung von Mehrdeutigkeiten, bietet es sich an, die Grammatiken der Sprachen zu betrachten.
	Dabei stellt sich die Frage nach der Definition von Mehrdeutigkeit
	und nach der Bedeutung von Mehrdeutigkeiten für die syntaktische Analyse im Parserbau.

	Die Definition einer mehrdeutigen Grammatik lässt isch wie folgt ausdrücken:
	``Eine Grammatik ist genau dann mehrdeutig, wenn es mindestens eine Eingabe gibt, die mehrere Parse-Bäume besitzt.''
	Daher ist eine Grammatik mehrdeutig, wenn ein Wort der Grammatik über mehrere Wege abgeleitet werden kann.

	Bei Mehrdeutigkeiten lässt sich zwischen lexikalischer und syntaktischer Mehrdeutigkeit unterscheiden.
	Lexikalische Mehrdeutigkeiten treten auf, wenn ein Token mehrere Bedeutungen haben kann.
	Ein Beispiel hierfür ist die lexikalische Mehrdeutigkeit des Tokens ``+'' in der Programmiersprache Java.

	In Java kann das Token ``+'' sowohl als arithmetischer Operator,
	als auch als Konkatenationsoperator von Strings verstanden werden.

	\begin{verbatim}
		//Hier wird der Operator als arithmetischer Operator verwendet
		int a = 1 + 2;
		//Hier wird der Operator als Konkatenationsoperator verwendet
		String b = "Hello" + "World";
	\end{verbatim}

	Solche lexikalischen Mehrdeutigkeiten werden im Lexer behandelt und im Weiteren nicht näher betrachtet.

	Syntaktische Mehrdeutigkeiten hingegen entstehen durch die Struktur der Grammatik selbst.
	Das wohl bekannteste Beispiel dafür ist das ``Dangling else''-Problem,
	welches in vielen bekannten Programmiersprachen auftritt.

	Eine beispielhafte Grammatik, die den Syntax eines if-else-Statements beschreibt, ist folgende:


	\begin{align*}
		ausdruck \rightarrow \textbf{if} \ bedingung \ \textbf{then} \ ausdruck \ \textbf{else} \ ausdruck \\
	\end{align*}

	Wie zu erkennen ist, ist diese Grammatik mehrdeutig, da unklar ist,
	welcher ``else''-Block zu welchem ``if''-Block gehört.
	Im folgenden sind zwei unterschiedliche Interpretationen des Wortes
	``if $\dots$ then if $\dots$ then $\dots$ else $\dots$'' dargestellt.

	\begin{figure}
		\centering
		\begin{forest}
		[\textit{ausdruck}
		[\textbf{if}]
		[\textit{bedingung}]
		[\textbf{then}]
		[\textit{ausdruck}
		[\textbf{if}]
		[\textit{bedingung}]
		[\textbf{then}]
		[\textit{ausdruck}]
		[\textbf{else}]
		[\textit{ausdruck}]
		]
		]
		\end{forest}
		\caption{Hier wird der else-Block der inneren if-Abfrage zugeordnet.}
		\label{fig:figure}
	\end{figure}

	\begin{figure}
		\centering
		\begin{forest}
		[\textit{ausdruck}
		[\textbf{if}]
		[\textit{bedingung}]
		[\textbf{then}]
		[\textit{ausdruck}
		[\textbf{if}]
		[\textit{bedingung}]
		[\textbf{then}]
		[\textit{ausdruck}]
		]
		[\textbf{else}]
		[\textit{ausdruck}]
		]
		\end{forest}
		\caption{In diesem Parse-Baum wird der else-Block der äußeren if-Abfrage zugeordnet.}
		\label{fig:figure2}
	\end{figure}

	Wie hier zu erkennen ist,
	können syntaktische Mehrdeutigkeiten zu unterschiedlichen Interpretationen desselben Quellcodes führen.
	Die Problematik dessen wird im Folgenden behandelt.


	\section{Problemstellung}

	Die Problematik von Mehrdeutigkeiten in Grammatiken besteht darin,
	dass ein Parser keinen eindeutigen Parse-Baum für ein zu parsendes Programm erzeugen kann.
	Wenn Mehrdeutigkeiten bei der konzeption einer Programmiersprache nicht vermieden werden können,
	muss der Parser in der Lage sein, diese zu handhaben.
	Um die korrekte Struktur eines mehrdeutigen Programmes zu ermitteln benötigt ein Parser
	entweder zusätzliche Informationen oder eine bestimmte Vorgehensweise.
	Mehrdeutigkeiten die nicht aufgelöst werden können, daher inhärent sind,
	werden an den Programmierer weitergegeben und erschweren die Entwicklung in der jeweiligen Sprache.


	\begin{flushleft}
		\begin{minipage}{0.48\textwidth}
			\begin{lstlisting}[style=cppStyle,label={lst:lstlisting1}]
class A {public: void func() {}};
class B {public: void func() {}};
class C: public A, public B {};
int main() {
	C c;
	c.func();
	return 0;
}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}{0.48\textwidth}
			\begin{lstlisting}[style=cppStyle,label={lst:lstlisting2}]
class A {public: void func() {}};
class B {public: void func() {}};
class C: public A, public B {};
int main() {
	C c;
	c.A::func();
	return 0;
}
			\end{lstlisting}
		\end{minipage}
	\end{flushleft}

	An diesem Beispiel wird deutlich,
	wieso es nicht sinnvoll ist, Mehrdeutigkeiten an den Entwickler weiterzugeben.
	Der Code in Listing \ref{lst:lstlisting1} ist mehrdeutig und wird auch als fehlerhaft erkannt.
	Die Mehrdeutigkeit kommt zu Stande, da die Klasse C von den Klassen A und B erbt,
	die beide eine Methode mit dem Namen ``func'' besitzen.
	Beim Aufruf der Methode ``func'' auf einem Objekt der Klasse C ist unklar,
	ob die Methode von der Oberklasse A oder B aufgerufen werden soll.
	Diese Mehrfachvererbung führt dazu, dass sich nun der Entwickler mit dieser Mehrdeutigkeit auseinandersetzen muss.
	Dies passiert nur, weil die Sprache C++ keine explizite Angabe der Klasse bei einem Methodenaufruf verlangt.

	Eine weitere Möglichkeit, Mehrdeutigkeiten aufzulösen, kann die Laufzeit eines Parsers beeinträchtigen
	und sollte daher gut abgewogen werden.
	Während eindeutige Sprachen einfach und effizient, beispielsweise mit einem LL-Parser, geparst werden können,
	ist das Parsen von mehrdeutigen Sprachen komplexer und weniger effizient.

	Eine weitere Problematik ist, dass es theoretisch nicht möglich ist zu entscheiden,
	ob eine gegebene Grammatik mehrdeutig ist oder nicht.
	Dieses Problem, auch bekannt als Post'sche Korrespondenzproblem
	spielt vor allem in der Konzeption neuer Programmiersprachen eine Rolle.
	Dieses Problem wird im nächsten Abschnitt genauer erläutert.


	\section{Vermeidung von Mehrdeutigkeiten}

	Da Mehrdeutigkeiten in Grammatiken sowohl in der Entwicklung des Parsers,
	als auch in der Anwendung der Sprache hinderlich sein können,
	ist es sinnvoll Mehrdeutigkeiten von vornherein zu vermeiden.
	Um eine Sprache eindeutig zu gestalten,
	können beispielsweise Assoziativitäts- und Vorrangregeln festgelegt werden,
	die eine eindeutige Struktur der Grammatik garantieren. \cite{wharton1976}
	Eine solche Sprache kann effizient und in linearer Zeit von einem LL-Parser verarbeitet werden.

	Allerdings kann es auch Nachteile haben, eine Sprache eindeutig zu gestalten.
	So ist die Grammatik einer mehrdeutigen Sprache oft einfacher, kürzer und intuitiver als die einer eindeutigen Sprache.
	So können die Eindeutigkeitsanforderungen and eine Sprache schnell Boilplate-Code verursachen.
	Es ist also eine Abwägung zwischen der Einfachheit des Parsers und der Komplexität und Lesbarkeit der Sprache zu treffen.

	Eine eindeutige Grammatik ist einfacher zu parsen und zu verstehen,
	aber sie kann auch eine Einschränkung der Sprache bedeuten.


	\section{Erkennung von Mehrdeutigkeiten}

	Wenn die Vermeidung von Mehrdeutigkeiten nicht möglich ist,
	muss der Parser in der Lage sein, Mehrdeutigkeiten zu erkennen und aufzulösen.
	Wie Mehrdeutigkeiten algorithmisch erkannt werden können wird im Folgenden erläutert.
	Zum einen besteht die Möglichkeit alle möglichen Ableitungen eines gegebenen Wortes zu ermitteln.
	Um mit dieser Methode zu prüfen, ob eine Grammatik mehrdeutig ist,
	können Wörter nach Heuristiken generiert und anschließend analysiert werden.
	Die Analyse kann entweder durch eine Tiefen- oder Breitensuche erfolgen.
	Bei der Tiefensuche wird die Grammatik rekursiv abgeleitet,
	während bei der Breitensuche alle möglichen Ableitungen auf einer Ebene betrachtet werden.
	HIER GRAFIK
	Dieser Ansatz basiert allerdings auf dem Brute-Force-Prinzip und ist daher nicht effizient.
	Effizientere Methoden sind bekannter Algorithmen wie derCYK-Algorithmus oder der Earley-Parser.
	Diese werden im Weiteren genauer erläutert und verglichen.

	- Suchbasierte Erkennung
	- bekannte Algorithmen
	- Tiefen/Breiten-Suche
	- Beispielhafte Implementierungen
	-Laufzeit vergleich
	- dynamic1 Algorithmus


	\section{Auflösung von Mehrdeutigkeiten}

	Sollte eine Grammatik mehrdeutig sein, so muss ein Parser in der Lage sein, diese Mehrdeutigkeiten aufzulösen.
	Eine Möglichkeit dies zu tun ist die Umformung der Grammatik in die Chomsky-Normalform.
	Bei der Umformung in die CNF können Mehrdeutigkeiten aufgelöst werden, müssen aber nicht.
	Ein weiterer Ansatz besteht darin, immer den ersten Ableitungsschritt zu wählen, wenn mehrere Ableitungen möglich sind.
	Dieser Ansatz ist jedoch nicht immer korrekt und kann zu falschen Interpretationen führen.
	Eine weitere Möglichkeit besteht darin, den Parser so zu erweitern,
	dass er in der Lage ist, mehrere Interpretationen zu verfolgen und zu vergleichen.
	Parser mit dieser Fähigkeit werden als Chart-Parser bezeichnet und im Folgenden genauer erläutert.
	Wenn zu einer Grammatik zusätzliche Regel wie Assoziativitäts- und Vorrangregeln existieren,
	können diese genutzt werden, um Mehrdeutigkeiten aufzulösen. \cite{springer2013}
	- LL(k)- und LR(k)-Parser im Detail
	- Unterschiede und Gemeinsamkeiten


	\section{Parsen von Mehrdeutigkeiten}

	- Erweiterte Heuristiken zur Mehrdeutigkeitsauflösung
	- Nutzung von Backtracking und Lookahead-Techniken
	- Parser-Generatoren
	- Spezifische Parser-Techniken (z.B. Early-Parser, Chart-Parser)
	- Abschließend: Vergleich LL, LR, LALR, SLR, Earley-Parser


	\section{Praktische Beispiele}

	Die Handhabung von Mehrdeutigkeiten ist neben dem Compilerbau
	auch in Bereichen wie der Sprachverarbeitung und dem maschinellen Lernen von Bedeutung.
	So behandeln Parser-Generatoren wie ANTLR oder Bison die Problematik der Mehrdeutigkeiten
	und bieten dem Nutzer Möglichkeiten zur Auflösung.
	Auch in der Sprachverarbeitung und dem maschinellen Lernen sind Mehrdeutigkeiten ein zentrales Thema.
	So können Sprachmodelle wie BERT oder GPT-3 durch die Handhabung von Mehrdeutigkeiten
	bessere Ergebnisse erzielen und die Effizienz der Verarbeitung steigern.
	STIMMT DAS SO?


	\section{Zusammenfassung und Ausblick}

	Abschließend lässt sich festhalten, dass Mehrdeutigkeiten in Grammatiken von Programmiersprachen
	eine zentrale Herausforderung beim Parsen darstellen.
	Die Vermeidung und Auflösung von Mehrdeutigkeiten kann die Effizienz und Zuverlässigkeit von Parsern erhöhen
	und die Entwicklung in der Sprache erleichtern.
	Sie kann aber auch zu Einschränkungen in der Sprache führen und die Lesbarkeit des Codes beeinträchtigen.
	Mehrdeutige Sprachen sind oft einfacher und intuitiver zu verstehen
	und die Tatsache, dass viele gängige Programmiersprachen wie C, Java oder Python mehrdeutig sind,
	zeigt, dass Mehrdeutigkeiten nicht immer ein Hindernis darstellen müssen.

	Neuere Programmiersprachen sind oft mehrdeutig und setzen auf fortschrittliche Parser-Techniken,
	um Mehrdeutigkeiten effizient aufzulösen.
	Auch existieren immer mehr Ansätze, die auf natürliche Sprache setzten
	und somit hin zu mehrdeutigen Sprachen tendieren.
	\cite{watrous2020,springer2013,wharton1976,watrous,parr,kemp1974,qi2018generalized,softwarelanguage,thorup1994}

	FAZIT: macht es den enticklern leichter


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
	\bibliographystyle{splncs04}
	\bibliography{refs}
\end{document}
